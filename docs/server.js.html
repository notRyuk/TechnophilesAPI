<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>server.js - TechnophilesAPI</title>
    
    <meta name="description" content="The API made by TriColored Technophiles SIH team for easy handling of frond-end apps." />
    
        <meta name="keywords" content="SIH, API, Disaster Management, Node, express" />
        <meta name="keyword" content="SIH, API, Disaster Management, Node, express" />
    
    
    
    <meta property="og:title" content="TechnophilesAPI"/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content=""/>
    
    <meta property="og:url" content=""/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="wrap">
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BlogObject.html">BlogObject</a><ul class='methods'><li data-type='method' style='display: none;'><a href="BlogObject.html#create">create</a></li><li data-type='method' style='display: none;'><a href="BlogObject.html#delete">delete</a></li><li data-type='method' style='display: none;'><a href="BlogObject.html#findBySimilarity">findBySimilarity</a></li><li data-type='method' style='display: none;'><a href="BlogObject.html#update">update</a></li></ul></li><li><a href="CollectionObject.html">CollectionObject</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CollectionObject.html#emailAlreadyExists">emailAlreadyExists</a></li><li data-type='method' style='display: none;'><a href="CollectionObject.html#findAll">findAll</a></li><li data-type='method' style='display: none;'><a href="CollectionObject.html#findById">findById</a></li><li data-type='method' style='display: none;'><a href="CollectionObject.html#isEmailValid">isEmailValid</a></li><li data-type='method' style='display: none;'><a href="CollectionObject.html#isPhoneValid">isPhoneValid</a></li><li data-type='method' style='display: none;'><a href="CollectionObject.html#phoneAlreadyExists">phoneAlreadyExists</a></li><li data-type='method' style='display: none;'><a href="CollectionObject.html#usernameAlreadyExists">usernameAlreadyExists</a></li><li data-type='method' style='display: none;'><a href="CollectionObject.html#verify">verify</a></li></ul></li><li><a href="NGOObject.html">NGOObject</a><ul class='methods'><li data-type='method' style='display: none;'><a href="NGOObject.html#create">create</a></li><li data-type='method' style='display: none;'><a href="NGOObject.html#getPinCodeInfo">getPinCodeInfo</a></li><li data-type='method' style='display: none;'><a href="NGOObject.html#updateAddress">updateAddress</a></li><li data-type='method' style='display: none;'><a href="NGOObject.html#updateCloseTime">updateCloseTime</a></li><li data-type='method' style='display: none;'><a href="NGOObject.html#updateDays">updateDays</a></li><li data-type='method' style='display: none;'><a href="NGOObject.html#updateEmail">updateEmail</a></li><li data-type='method' style='display: none;'><a href="NGOObject.html#updateLatitude">updateLatitude</a></li><li data-type='method' style='display: none;'><a href="NGOObject.html#updateLongitude">updateLongitude</a></li><li data-type='method' style='display: none;'><a href="NGOObject.html#updateName">updateName</a></li><li data-type='method' style='display: none;'><a href="NGOObject.html#updatePhone">updatePhone</a></li><li data-type='method' style='display: none;'><a href="NGOObject.html#updateStartTime">updateStartTime</a></li><li data-type='method' style='display: none;'><a href="NGOObject.html#verifyNGO">verifyNGO</a></li></ul></li><li><a href="UserObject.html">UserObject</a><ul class='methods'><li data-type='method' style='display: none;'><a href="UserObject.html#updateEmail">updateEmail</a></li><li data-type='method' style='display: none;'><a href="UserObject.html#updateEncryption">updateEncryption</a></li><li data-type='method' style='display: none;'><a href="UserObject.html#updateName">updateName</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="BlogRoutes.html">BlogRoutes</a></li><li><a href="NGORoutes.html">NGORoutes</a></li><li><a href="UserRoutes.html">UserRoutes</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AddressOfNGO">AddressOfNGO</a></li><li><a href="global.html#Blog">Blog</a></li><li><a href="global.html#Error">Error</a></li><li><a href="global.html#LocationOfNGO">LocationOfNGO</a></li><li><a href="global.html#NameOfUser">NameOfUser</a></li><li><a href="global.html#NGO">NGO</a></li><li><a href="global.html#searchBlog">searchBlog</a></li><li><a href="global.html#TimingsOfNGO">TimingsOfNGO</a></li><li><a href="global.html#User">User</a></li><li><a href="global.html#UserBlogSchema">UserBlogSchema</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">server.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import express from "express";
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import compression from "compression";

import { PORT } from "./config.js";
import { UserObject, CollectionObject, BlogObject } from "./db.js";
import { user, blog, ngo } from "./mongoose.js";

const app = express()

app.use(express.json())
app.use(compression())

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
/**
 *  TODO: Updated the res.send function with a param of Object which contains key status of status mentioned above and a key doc with the given doc
 *  The above has to be only done only when the send contains a 200 status else status is already present.
 * 
 *  Add the encryption algorithm to all the methods
*/

/**
 * @namespace UserRoutes
*/
/**
 * @namespace BlogRoutes
*/
/**
 * @namespace NGORoutes
*/

/**
 * This routes helps in finding a collection element by ID
 * @name FindByID
 * @route {GET} /user/findByID
 * @memberof UserRoutes
 * @bodyparam {String} id The id of the user to be searched for
*/
/**
 * This routes helps in finding a collection element by ID
 * @name FindByID
 * @route {GET} /blog/findByID
 * @memberof BlogRoutes
 * @bodyparam {String} id he id of the blog to be searched for
*/
/**
 * This routes helps in finding a collection element by ID
 * @name FindByID
 * @route {GET} /ngo/findByID
 * @memberof NGORoutes
 * @bodyparam {String} id The id of the collection to be searched for
*/
/**
 * This routes helps in finding a collection element by ID
 * @name findAll
 * @memberof UserRoutes
 * @route {GET} /user/findAll 
*/
/**
 * This routes helps in finding a collection element by ID
 * @name findAll
 * @memberof BlogRoutes
 * @route {GET} /blog/findAll 
*/
/**
 * This routes helps in finding a collection element by ID
 * @name findAll
 * @memberof NGORoutes
 * @route {GET} /blog/findAll 
 */
app.get(/^\/(user|blog|ngo)\/(findByID|findAll)$/, async (req, res) => {
    const path = req.path
    const body = req.body
    if(path.includes("findByID") &amp;&amp; !body.id) {
        res.status(404)
        res.send({
            status: 404,
            error: "The id param id required to find in the body.",
            comment: "Send request body with id param"
        })
        return
    }
    var obj = null
    if(path.includes("user")) {
        obj = new CollectionObject(body.id, user)
    }
    if(path.includes("blog")) {
        obj = new CollectionObject(body.id, blog)
    }
    if(path.includes("ngo")) {
        obj = new CollectionObject(body.id, ngo)
    }
    obj = path.includes("findByID")?(await obj.findById(body.id)):(await obj.findAll())
    if(!obj) {
        res.status(404)
        res.send({
            status: 404,
            error: "There is nothing in the collection.",
            comment: "Insert or Create some documents to use this method."
        })
        return
    }
    res.status(200)
    res.send({
        status: 200,
        col: obj
    })
    return
})

/**
 * This method creates a new user object in the database.
 * @name CreateUser
 * @memberof UserRoutes
 * @route {POST} /user/create
 * @bodyparam {String} userName The username of the user 
 * @bodyparam {String} firstName The first name of the user 
 * @bodyparam {String} lastName The last name of that user
 * @bodyparam {String} password The encrypted password of the user
 * @bodyparam {String} email The email of the user
 */
app.post("/user/create", async (req, res) => {
    const body = req.body
    var keys = Object.keys(body)
    var values = Object.values(body)
    var required = ["userName", "firstName", "lastName", "password", "email"]
    for(var i of required) {
        if(!keys.includes(i) || values[keys.indexOf(i)].length === 0) {
            res.status(404)
            res.send({
                status: 404,
                error: `The ${i} parameter is missing or empty in the request body.`,
                comment: "The required parameters are needed for making a user."
            })
            return
        }
    }
    var newUser = (await new UserObject(
        body.userName.trim(),
        body.firstName.trim(),
        body.lastName.trim(),
        body.password.trim(),
        body.email.trim(),
        []
    ).create()).doc
    res.status(200)
    res.send(newUser)
})

/**
 * This method updates the username of the mentioned user.
 * @name UpdateUserName
 * @memberof UserRoutes
 * @route {POST} /user/updateUserName
 * @bodyparam {String} userName The username of the user
 * @bodyparam {String} token The token which is returned
 * @bodyparam {String} newUserName The new username of the user
 */
app.post("/user/updateUserName", async (req, res) => {
    const body = req.body
    var keys = Object.keys(body)
    var values = Object.values(body)
    var required = ["userName", "token", "newUserName"]
    for(var i of required) {
        if(!keys.includes(i) || values[keys.indexOf(i)].length === 0) {
            res.status(404)
            res.send({
                status: 404,
                error: `The ${i} parameter is missing or empty in the request body.`,
                comment: "The required parameters are needed for making a user."
            })
            return
        }
    }
    if(body.userName === body.newUserName) {
        res.status(404)
        res.send({
            status: 404,
            error: "The new username and old username are equal.",
            comment: "The new username that is to updated has to be different."
        })
        return
    }
    var newUser = (await new UserObject(
        body.userName.trim(),
        "",
        "",
        "",
        "",
        []
    ).findById(body.userName))
    if(!newUser) {
        res.status(404)
        res.send({
            status: 404,
            error: "The input user is not found in the database.",
            comment: "Enter a valid username!"
        })
        return
    }
    newUser = (await new UserObject(
        newUser._id,
        newUser.name.first,
        newUser.name.last,
        newUser.encryption,
        newUser.email,
        newUser.blogs
    ).updateUserName(body.newUserName))
    if(newUser.status) {
        res.status(newUser.status)
        res.send(newUser)
        return
    }
    res.status(200)
    res.send(newUser.doc)
    return
})

/**
 * This method updates the password of the mentioned user.
 * @name UpdatePassword
 * @memberof UserRoutes
 * @route {POST} /user/updatePassword
 * @bodyparam {String} userName The username of the user
 * @bodyparam {String} token The tokenized password of the user
 * @bodyparam {String} newPassword The new tokenized of the user
 */
app.post("/user/updatePassword", async (req, res) => {
    const body = req.body
    var keys = Object.keys(body)
    var values = Object.values(body)
    var required = ["userName", "token", "newPassword"]
    for(var i of required) {
        if(!keys.includes(i) || values[keys.indexOf(i)].length === 0) {
            res.status(404)
            res.send({
                status: 404,
                error: `The ${i} parameter is missing or empty in the request body.`,
                comment: "The required parameters are needed for making a user."
            })
            return
        }
    }
    // Encryption of the new password and change the conditional statement
    if(body.token === body.newPassword) {
        res.status(404)
        res.send({
            status: 404,
            error: "The new password and old password are equal.",
            comment: "The new password that is to updated has to be different."
        })
        return
    }
    var newUser = (await new UserObject(
        body.userName.trim(),
        "",
        "",
        "",
        "",
        []
    ).findById(body.userName))
    if(!newUser) {
        res.status(404)
        res.send({
            status: 404,
            error: "The input user is not found in the database.",
            comment: "Enter a valid username!"
        })
        return
    }
    newUser = (await new UserObject(
        newUser._id,
        newUser.name.first,
        newUser.name.last,
        newUser.encryption,
        newUser.email,
        newUser.blogs
    ).updateEncryption(body.newPassword)) // Enter the param for new encrypted password
    if(newUser.status) {
        res.status(newUser.status)
        res.send(newUser)
        return
    }
    res.status(200)
    res.send(newUser.doc)
    return
})

/**
 * The method to update the email id of the user
 * @name UpdateEmail
 * @memberof UserRoutes
 * @route {POST} /user/updateEmail
 * @bodyparam {String} userName The username of the user
 * @bodyparam {String} The tokenized password of the user
 * @bodyparam {String} email The current email of the user
 * @bodyparam {String} newEmail The new email of the user
 */
app.post("/user/updateEmail", async (req, res) => {
    const body = req.body
    var keys = Object.keys(body)
    var values = Object.values(body)
    var required = ["userName", "token", "email", "newEmail"]
    for(var i of required) {
        if(!keys.includes(i) || values[keys.indexOf(i)].length === 0) {
            res.status(404)
            res.send({
                status: 404,
                error: `The ${i} parameter is missing or empty in the request body.`,
                comment: "The required parameters are needed for making a user."
            })
            return
        }
    }
    if(body.email === body.newEmail) {
        res.status(404)
        res.send({
            status: 404,
            error: "The new email and old email are equal.",
            comment: "The new email that is to updated has to be different."
        })
        return
    }
    var newUser = (await new UserObject(
        body.userName.trim(),
        "",
        "",
        "",
        "",
        []
    ).findById(body.userName))
    if(!newUser) {
        res.status(404)
        res.send({
            status: 404,
            error: "The input user is not found in the database.",
            comment: "Enter a valid username!"
        })
        return
    }
    newUser = (await new UserObject(
        newUser._id,
        newUser.name.first,
        newUser.name.last,
        newUser.encryption,
        newUser.email,
        newUser.blogs
    ).updateEmail(body.newEmail))
    if(newUser.status) {
        res.status(newUser.status)
        res.send(newUser)
        return
    }
    res.status(200)
    res.send(newUser.doc)
    return
})

/**
 * The method to update the name of the user
 * @name UpdateName
 * @memberof UserRoutes
 * @route {POST} /user/updateName
 * @bodyparam {String} userName The username of the user
 * @bodyparam {String} token The tokenized password of the user
 * @bodyparam {NameOfUser} name The current name of the user
 * @bodyparam {NameOfUser} newName The new name of the user
 */
app.post("/user/updateName", async (req, res) => {
    const body = req.body
    var keys = Object.keys(body)
    var values = Object.values(body)
    var required = ["userName", "token", "name", "newName"]
    for(var i of required) {
        if(!keys.includes(i) || values[keys.indexOf(i)].length === 0) {
            res.status(404)
            res.send({
                status: 404,
                error: `The ${i} parameter is missing or empty in the request body.`,
                comment: "The required parameters are needed for making a user."
            })
            return
        }
    }
    var name = {
        first: body.name.first || "",
        last: body.name.last || ""
    }
    name.first = (name.first!==body.newName.first)?body.newName.first:name.first
    name.last = (name.last!==body.newName.last)?body.newName.last:name.last
    var newUser = (await new UserObject(
        body.userName.trim(),
        "",
        "",
        "",
        "",
        []
    ).findById(body.userName))
    if(!newUser) {
        res.status(404)
        res.send({
            status: 404,
            error: "The input user is not found in the database.",
            comment: "Enter a valid username!"
        })
        return
    }
    newUser = (await new UserObject(
        newUser._id,
        newUser.name.first,
        newUser.name.last,
        newUser.encryption,
        newUser.email,
        newUser.blogs
    ).updateName(name.first, name.last))
    if(newUser.status) {
        res.status(newUser.status)
        res.send(newUser)
        return
    }
    res.status(200)
    res.send(newUser.doc)
    return
})

/**
 * The method to delete the user from the database
 * @name DeleteUser
 * @memberof UserRoutes
 * @route {DELETE} /user/delete
 * @bodyparam {String} userName The username of the user
 * @bodyparam {String} token The tokenized password of the user
 */
app.delete("/user/delete", async (req, res) => {
    const body = req.body
    var keys = Object.keys(body)
    var values = Object.values(body)
    var required = ["userName", "token"]
    for(var i of required) {
        if(!keys.includes(i) || values[keys.indexOf(i)].length === 0) {
            res.status(404)
            res.send({
                status: 404,
                error: `The ${i} parameter is missing or empty in the request body.`,
                comment: "The required parameters are needed for making a user."
            })
            return
        }
    }
    var newUser = (await new UserObject(
        body.userName,
        "",
        "",
        "",
        "",
        []
    ).findById(body.userName))
    if(!newUser) {
        res.status(404)
        res.send({
            status: 404,
            error: "The input user is not found in the database.",
            comment: "Enter a valid username!"
        })
        return
    }
    newUser = (await new UserObject(
        newUser._id,
        newUser.name.first,
        newUser.name.last,
        newUser.encryption,
        newUser.email,
        newUser.blogs
    ).delete())
    if(newUser.status) {
        res.status(newUser.status)
        res.send(newUser)
        return
    }
    res.status(200)
    res.send(newUser)
    return
})

/**
 * The method to fetch users by name
 * @name FindByName
 * @memberof UserRoutes
 * @route {GET} /user/findByName
 * @bodyparam {NameOfUser} name The name of the user to search
 */
app.get("/user/findByName", async (req, res) => {
    const body = req.body
    var name = {
        first: "",
        last: ""
    }
    if(!body.name) {
        res.status(404)
        res.send({
            status: 404,
            error: "The request body does not have a name key.",
            comment: "Send a name parameter with first and last keys in it."
        })
        return
    }
    name.first = body.name.first?body.name.first.trim():""
    name.last = body.name.last?body.name.last.trim():""
    if(name.first.trim() === "" &amp;&amp; name.last.trim() === "") {
        res.status(404)
        res.send({
            status: 404,
            error: "The name object does not have a first name or last name",
            comment: "Add a first name or last name in the name object with the keys first and last."
        })
        return
    }
    var newUser = new UserObject()
    if(name.first.trim() !== "" &amp;&amp; (!name.last.trim() || name.last.trim() === "")) {
        newUser = await newUser.findByFirstName(name.first)
    }
    if((!name.first.trim() || name.first.trim() === "") &amp;&amp; name.last.trim() !== "") {
        newUser = await newUser.findByLastName(name.last)
    }
    if(name.first.trim() !== "" &amp;&amp; name.last.trim() !== "") {
        newUser = await newUser.findByFullName(name.first.trim() + " " + name.last.trim())
    }
    if(!newUser) {
        res.status(404)
        res.send({
            status: 404,
            error: "The database refused to connect.",
            comment: "Try reconnecting after sometime or change the database URI"
        })
        return
    }
    res.status(200)
    res.send({
        status: 200,
        col: newUser
    })
})

/**
 * The method to identify the users by email
 * @name FindByEmail
 * @memberof UserRoutes
 * @route {GET} /user/findByEmail
 * @bodyparam {String} email The email id to fetch
 */
app.get("/user/findByEmail", async (req, res) => {
    const body = req.body
    if(!body.email || body.email.length === 0) {
        res.status(404)
        res.send({
            status: 404,
            error: "There is not email parameter in the request body or it is empty.",
            comment: "Pass a valid email to check."
        })
        return
    }
    var newUser = new UserObject()
    if(!newUser.isEmailValid(body.email.trim())) {
        res.status(404)
        res.send({
            status: 404,
            error: "The entered email is not in a valid format.",
            comment: "Please enter a valid email with correct format."
        })
        return
    }
    newUser = await newUser.findByEmail(body.email.trim())
    if(!newUser) {
        res.status(404)
        res.send({
            status: 404,
            error: "The database refused to connect.",
            comment: "Try reconnecting after sometime."
        })
        return
    }
    res.status(200)
    res.send({
        status: 200,
        col: newUser
    })
    return
})

/**
 * The method to create the blog written by the user
 * @name CreateBlog
 * @memberof BlogRoutes
 * @route {POST} /blog/create
 * @bodyparam {String} userName The username of the user that wrote the blog
 * @bodyparam {String} name The name of the blog
 * @bodyparam {String} [description=""] The description of the blog
 * @bodyparam {String} content The markdown'd content of the blog
 */
app.post("/blog/create", async (req, res) => {
    const body = req.body
    var keys = Object.keys(body)
    var values = Object.values(body)
    var required = ["userName", "name", "description", "content"]
    for(var i of required) {
        if(!keys.includes(i) || values[keys.indexOf(i)].length === 0) {
            res.status(404)
            res.send({
                status: 404,
                error: `The ${i} parameter is missing or empty in the request body.`,
                comment: "The required parameters are needed for making a blog."
            })
            return
        }
    }
    var newBlog = new BlogObject(body.userName+"__blog__1", "", "", "")
    var newUser = await newBlog.__verifyUser()
    if(!newUser) {
        res.status(404)
        res.send({
            status: 404,
            error: "The mentioned user does not exist in the database",
            comment: "Try providing a user that actually exists"
        })
        return
    }
    newBlog = await new BlogObject(
        newUser._id+"__blog__"+(newUser.blogs.length+1), 
        body.name, 
        body.description, 
        body.content
    ).create()
    if(!newBlog) {
        res.status(404)
        res.send({
            status: 404,
            error: "The database refused to connect.",
            comment: "Try reconnecting after some time or use a different URL/URI."
        })
        return
    }
    res.status(newBlog.status || 200)
    res.send(newBlog.doc || newBlog)
})

/**
 * The method to update the blog.
 * &lt;br>
 * &lt;b>Note:&lt;/b> Any one of the name or description or content have to be present to update the blog.
 * @name UpdateBlog
 * @memberof BlogRoutes
 * @route {POST} /blog/update
 * @bodyparam {String} [newName=""] The new name of the blog
 * @bodyparam {String} [newDescription=""] The new description of the blog
 * @bodyparam {String} [newContent=""] The new content of the blog
 */
app.post("/blog/update", async (req, res) => {
    const body = req.body
    if(!body.id || body.id.trim().length === 0) {
        res.status(404)
        res.send({
            status: 404,
            error: "The request body does not have a key called id.",
            comment: "Send the blog id to be updated."
        })
        return
    }
    var newBlog = {
        name: (body.newName &amp;&amp; body.newName.length > 0)?body.newName:"",
        description: (body.newDescription &amp;&amp; body.newDescription.length > 0)?body.newDescription:"",
        content: (body.newContent &amp;&amp; body.newContent.length > 0)?body.newContent:""
    }
    newBlog = await new BlogObject(body.id.trim()).update(newBlog.name, newBlog.description, newBlog.content)
    if(!newBlog) {
        res.status(404)
        res.send({
            status: 404,
            error: "The database refused to connect.",
            comment: "Try reconnecting after some time or use a different URL/URI."
        })
        return
    }
    res.status(newBlog.status || 200)
    res.send(newBlog.doc || newBlog)
})

/**
 * The method to delete the blog written by the user
 * @name DeleteBlog
 * @memberof BlogRoutes
 * @route {DELETE} /blog/delete
 * @bodyparam {String} id The blog to delete
 */
app.delete("/blog/delete", async (req, res) => {
    const body = req.body
    if(!body.id || body.id.trim().length === 0) {
        res.status(404)
        res.send({
            status: 404,
            error: "The request body does not have a key called id.",
            comment: "Send the blog id to be updated."
        })
        return
    }
    var newBlog = await new BlogObject(body.id).delete()
    if(!newBlog) {
        res.status(404)
        res.send({
            status: 404,
            error: "The database refused to connect.",
            comment: "Try reconnecting after some time or use a different URL/URI."
        })
        return
    }
    res.status(newBlog.status || 200)
    res.send(newBlog.doc || newBlog)
})

/**
 * The method to find the blog by name
 * @name FindByName
 * @memberof BlogRoutes
 * @route {GET} /blog/findByName
 * @bodyparam {String} key The key to search in the blogs
 */
app.get("/blog/findByName", async (req, res) => {
    const body = req.body
    if(!body.key || body.key.trim().length === 0) {
        res.status(404)
        res.send({
            status: 404,
            error: "The request body does not have a key to search.",
            comment: "Send the blog id to be updated."
        })
        return
    }
    var newBlog = await new BlogObject(body.id).findBySimilarity(body.key.trim())
    if(!newBlog) {
        res.status(404)
        res.send({
            status: 404,
            error: "The database refused to connect.",
            comment: "Try reconnecting after some time or use a different URL/URI."
        })
        return
    }
    res.status(newBlog.status || 200)
    res.send((typeof newBlog !== Array)?newBlog:{status: 200, col: newBlog})
})

// app.post("/ngo/create", async (req, res) => {

// })

app.use(express.static("docs"))

app.get("/", (_, res) => {
    res.sendFile("./docs/index.html")
})

app.get("*", (_, res) => {
    res.status(404)
    res.send({
        status: 404,
        error: "BadRequest! URL/Path not found!",
        comment: "Please enter a valid Path."
    })
})

app.post("*", (_, res) => {
    res.status(404)
    res.send({
        status: 404,
        error: "BadRequest! URL/Path not found!",
        comment: "Please enter a valid Path."
    })
})

app.delete("*", (_, res) => {
    res.status(404)
    res.send({
        status: 404,
        error: "BadRequest! URL/Path not found!",
        comment: "Please enter a valid Path."
    })
})

console.log("The app is listening on the port: ", PORT)
app.listen(PORT)
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


    <link type="text/css" rel="stylesheet" href="./style.css">
    
</body>
</html>
